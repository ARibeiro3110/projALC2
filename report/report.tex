\documentclass[12pt,a4paper]{article}
\usepackage[a4paper, margin=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{pdflscape}
\usepackage{svg}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage[absolute,overlay]{textpos}
\usepackage{lipsum}

\newcommand{\reporttitle}{Projeto 2 -- Flying Tourist Problem}
\newcommand{\authorname}{Afonso da Conceição Ribeiro}
\newcommand{\authorid}{ist1102763}
\newcommand{\authorgroup}{20}
\newcommand{\reportauthor}{\textbf{\authorname} (\authorid) -- Grupo \textbf{\authorgroup}}
\newcommand{\istul}{Instituto Superior Técnico -- Universidade de Lisboa}
\newcommand{\reportcourse}{Algoritmos para Lógica Computacional}
\newcommand{\reportyear}{2024/2025}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=blue,
    citecolor=blue,
    pdftitle={\reporttitle},
    pdfpagemode=FullScreen,
}

\pagestyle{fancy}
\fancyhf{}
\lhead{\reporttitle}
\rhead{\reportcourse}
\lfoot{\reportauthor}
\rfoot{\thepage}


\renewcommand{\footrulewidth}{0.2pt}

\renewcommand\thesection{\arabic{section}.}
\renewcommand\thesubsection{\thesection\arabic{subsection}.}
\renewcommand\thesubsubsection{\thesubsection\arabic{subsubsection}.}

\begin{document}
    \begin{titlepage}

        \begin{textblock*}{0cm}(10cm, 0cm)
            \includegraphics[width=10cm]{Logo IST.jpg}
        \end{textblock*}

        \centering
        \vspace*{5cm}
        {\Huge \textbf{\reporttitle} \par}

        \vspace{0.5cm}
        {\LARGE \reportcourse \par}

        \vspace{0.5cm}
        {\large \reportyear \par}

        \vspace{2cm}
        {\large \reportauthor \par}
        
        \vspace{0.25cm}
        {\large \istul \par}

        \vfill
        \renewcommand{\contentsname}{Índice}
        \tableofcontents

        \thispagestyle{empty}
        \clearpage

    \end{titlepage}


    \setcounter{page}{2}
    \setlength{\parskip}{0em}


    \section{Problema a resolver}
        O Flying Tourist Problem é um problema de otimização em que um turista precisa de planear uma viagem por várias cidades, minimizando o custo dos bilhetes de avião. Este inicia e termina a viagem na mesma cidade, e o número de noites que passa em cada cidade pertence a um intervalo definido para cada uma. A ordem das cidades a visitar não é predefinida, e o turista é obrigado a utilizar apenas voos diretos. O problema é modelado como um problema de Satisfiability Modulo Theories (SMT) e resolvido utilizando um solver correspondente.

    \section{Como instalar e correr o projeto}
        \begin{itemize}
            \item Clonar o repositório do GitLab.
            \item Navegar até à diretoria do projeto.
            \item Correr o projeto utilizando o seguinte comando: \\
                  \texttt{python3 project2.py < input.ttp > output.myout}
            \item Comparar o conteúdo do ficheiro de output obtido com o output esperado.
        \end{itemize}

    \section{Codificações experimentadas para o problema}

        A partir de um ficheiro de input que represente uma instância do problema, obtêm-se as seguintes variáveis e conjuntos:
        \begin{itemize}
            \item $\mathcal{C}$: conjunto das cidades que o turista pretende visitar e a cidade de origem; $n = \lvert \mathcal{C} \rvert$
            \item $base$: a cidade de origem, $base \in \mathcal{C}$
            \item $k_c^m$: número mínimo de noites a passar na cidade $c$,
                  $\forall c \in \mathcal{C} \setminus \{base\}$
            \item $k_c^M$: número máximo de noites a passar na cidade $c$,
                  $\forall c \in \mathcal{C} \setminus \{base\}$
            \item $\mathcal{F}$: conjunto dos voos em consideração; $m = \lvert \mathcal{F} \rvert$
            \item $d_f$: data do voo $f$, $\forall f \in \mathcal{F}$
            \item $w_f$: custo do voo $f$, $\forall f \in \mathcal{F}$
        \end{itemize}
        E definem-se as seguintes:
        \begin{itemize}
            \item $x_i = 1$ se e só se o voo $f_i$ é escolhido
            \item $k_c$: número efetivo de noites a passar na cidade c,
                  $\forall c \in \mathcal{C} \setminus \{base\}$
            \item $K = d_{f_m} - d_{f_1}$: número de noites entre a primeira e a última datas com voos
            \item $K_m = \sum_{c \in \mathcal{C}}{k_c^m}$: número mínimo de noites a viajar
            \item $\mathcal{O}_c \subset \mathcal{F}$: conjunto dos voos com origem na cidade $c$, $\forall c \in \mathcal{C}$
            \item $\mathcal{D}_c \subset \mathcal{F}$: conjunto dos voos com destino à cidade $c$, $\forall c \in \mathcal{C}$
        \end{itemize}
        Os conjutos de cláusulas utilizadas nas codificações do problema são descritos nas subsecções seguintes.

    \subsection{Com filtragem de voos compatíveis}
        \label{1}
        Pretende-se minimizar o valor da seguinte expressão:
        \begin{equation}
            \sum_{i = 1}^m x_i \cdot w_i
            \label{minimize_1}
        \end{equation}
        O primeiro conjunto de cláusulas garante que, para cada cidade, são escolhidos exatamente um voo com destino e um com origem na mesma.
        \begin{equation}
            \bigwedge_{c \in \mathcal{C}}
            \left(
            \sum_{\substack{i = 1 \\
                            f_i \in \mathcal{D}_c}}
                ^{m}
                {x_i} = 1
            \land
            \sum_{\substack{i = 1 \\
                            f_i \in \mathcal{O}_c}}
                ^{m}
                {x_i} = 1
            \right)
            \label{exactly_one_per_c_1}
        \end{equation}
        O segundo conjunto de cláusulas assegura que, para cada cidade visitada, se um certo voo com destino nessa cidade é escolhido, então o voo com origem nessa cidade escolhido acontece entre $k_c^m$ e $k_c^M$ dias depois.
        \begin{equation}
            \bigwedge_{c \in \mathcal{C} \setminus \{base\}}
            \left(
            \bigwedge_{\substack{i = 1 \\
                                 f_i \in \mathcal{D}_c}}
                     ^{m}
            \left(
            x_i \Rightarrow
            \bigvee_{\substack{j = 1 \\
                               f_j \in \mathcal{O}_c \\
                               k_c^m \leq d_{f_j} - d_{f_i} \leq k_c^M}}
                ^{m}
                {x_j}
            \right)
            \right)
            \label{k_nights_departures}
        \end{equation}
        O terceiro conjunto de cláusulas é semelhante ao anterior, garantindo que, para cada cidade visitada, se um certo voo com origem nessa cidade é escolhido, então o voo com destino nessa cidade escolhido acontece entre $k_c^m$ e $k_c^M$ dias antes. Este conjunto de cláusulas é redundante, pois a sua semântica é já garantida por $\varphi_2$, mas a sua presença é relevante porque reduz o espaço de procura, aumentando a eficiência do programa.
        \begin{equation}
            \bigwedge_{c \in \mathcal{C} \setminus \{base\}}
            \left(
            \bigwedge_{\substack{i = 1 \\
                                 f_i \in \mathcal{O}_c}}
                     ^{m}
            \left(
            x_i \Rightarrow
            \bigvee_{\substack{j = 1 \\
                               f_j \in \mathcal{D}_c \\
                               k_c^m \leq d_{f_i} - d_{f_j} \leq k_c^M}}
                ^{m}
                {x_j}
            \right)
            \right)
            \label{k_nights_arrivals}
        \end{equation}
        No caso da cidade $base$, é o voo com destino na cidade que tem de acontecer depois do voo com origem, mais especificamente entre $K_m$ e $K$ dias depois. Isto é cumprido pelo seguinte conjunto de cláusulas, análogo aos últimos dois para a situação específica da cidade $base$.
        \begin{equation}
            \bigwedge_{\substack{i = 1 \\
                                 f_i \in \mathcal{O}_{base}}}
                     ^{m}
            \left(
            x_i \Rightarrow
            \bigvee_{\substack{j = 1 \\
                               f_j \in \mathcal{D}_{base} \\
                               K_m \leq d_{f_j} - d_{f_i} \leq K}}
                ^{m}
                {x_j}
            \right)
            \land
            \bigwedge_{\substack{i = 1 \\
                                 f_i \in \mathcal{D}_{base}}}
                     ^{m}
            \left(
            x_i \Rightarrow
            \bigvee_{\substack{j = 1 \\
                               f_j \in \mathcal{O}_{base} \\
                               K_m \leq d_{f_i} - d_{f_j} \leq K}}
                ^{m}
                {x_j}
            \right)
            \label{K_nights_base}
        \end{equation}
        Finalmente, a seguinte cláusula não afeta o espaço de procura, estando presente apenas com o objetivo de forçar o solver a resolver o problema utilizando a teoria de Aritmética Linear de Inteiros.
        \begin{equation}
            \sum_{c \in \mathcal{C}}{k_c} \leq K
            \label{kc_sum}
        \end{equation}     
    
    \subsection{Com variáveis para os dias de chegada e de partida de cada cidade}
        \label{2}
        Obtêm-se, adicionalmente, as seguintes variáveis:
        \begin{itemize}
            \item $c_f^O$: cidade de origem do voo $f$, $\forall f \in \mathcal{F}$
            \item $c_f^D$: cidade de destino do voo $f$, $\forall f \in \mathcal{F}$
        \end{itemize}
        Definem-se as seguintes novas variáveis inteiras:
        \begin{itemize}
            \item $d_c^C$: data de chegada à cidade $c$, $\forall c \in \mathcal{C} \setminus \{base\}$
            \item $d_c^P$: data de partida da cidade $c$, $\forall c \in \mathcal{C} \setminus \{base\}$
        \end{itemize}
        Pretende-se minimizar o valor da seguinte expressão:
        \begin{equation}
            \sum_{i = 1}^m x_i \cdot w_i
            \label{minimize_1}
        \end{equation}
        O primeiro conjunto de cláusulas estabelece os limites das datas de chegada e partida de cada cidade, que devem estar entre o primeiro e o último dias em que existem voos.
        \begin{equation}
            \bigwedge_{c \in \mathcal{C}}
            \left(
            \left( d_{f_1} \leq d_c^C \leq d_{f_m} \right)
            \land
            \left( d_{f_1} \leq d_c^P \leq d_{f_m} \right)
            \right)
            \label{minimize_2}
        \end{equation}
        O segundo conjunto de cláusulas garante que, para cada cidade, são escolhidos exatamente um voo com destino e um com origem na mesma.
        \begin{equation}
            \bigwedge_{c \in \mathcal{C}}
            \left(
            \sum_{\substack{i = 1 \\
                            f_i \in \mathcal{D}_c}}
                ^{m}
                {x_i} = 1
            \land
            \sum_{\substack{i = 1 \\
                            f_i \in \mathcal{O}_c}}
                ^{m}
                {x_i} = 1
            \right)
            \label{exactly_one_per_c_2}
        \end{equation}
        O terceiro conjunto de cláusulas assegura que, se um voo é escolhido, a data do voo é igual à data de partida da sua cidade de origem e à data de chegada à sua cidade de destino.
        \begin{equation}
            \bigwedge_{f_i \in \mathcal{F}}
            \left(
            x_i \Rightarrow
            \left( d_{c_{f_i}^D}^C = d_{f_i} \land d_{c_{f_i}^O}^P = d_{f_i} \right)
            \right)
            \label{flight_date}
        \end{equation}
        O quarto conjunto de cláusulas garante que o número de noites passado em cada cidade está dentro dos limites.
        \begin{equation}
            \bigwedge_{c \in \mathcal{C}}C
            \left(
            \left( k_c^m \leq d_c^P - d_c^C \right)
            \land
            \left( d_c^P - d_c^C \leq k_c^M \right)
            \right)
        \end{equation}
        O quinto conjunto de cláusulas garante que, para cada par de cidades visitadas diferentes, estas não têm estadias sobrepostas.
        \begin{equation}
            \bigwedge_{\substack{c_1 \in \mathcal{C} \setminus \{base\} \\
                                 c_2 \in \mathcal{C} \setminus \{base\} \\
                                 c_1 \neq c_2}}
            \left(
            \left( d_{c_1}^P <= d_{c_2}^C \right)
            \lor
            \left( d_{c_2}^P <= d_{c_1}^C \right)
            \right)
        \end{equation}
        Finalmente, o sexto conjunto de cláusulas assegura que, nos dias de partida e de chegada à cidade $base$, há, respetivamente, chegada e partida a exatamente uma outra cidade. Note-se que a comparação de duas variáveis é um valor booleano, correspondente aos inteiros 1 ou 0 caso seja, respetivamente, verdadeiro ou falso.
        \begin{equation}
            \left(
            \sum_{c \in \mathcal{C}}
            \left(
            d_{base}^P = d_c^C
            \right)
            = 1
            \right)
            \land
            \left(
            \sum_{c \in \mathcal{C}}
            \left(
            d_{base}^C = d_c^P
            \right)
            \right)
            = 1
        \end{equation}
        
    \section{Algoritmo e configurações usadas}
        O solver é uma instância da classe \texttt{Optimize}, da biblioteca \texttt{z3}. Vão-lhe sendo adicionadas cláusulas utilizando o método \texttt{append} e, no fim, este contém a fórmula SMT que codifica o problema, chamando-se o método \texttt{check} para verificar se a fórmula é satisfazível e, caso seja, o método \texttt{model} devolve uma atribuição das variáveis da fórmula.

        Finalmente, encontram-se as variáveis $x_i$ às quais foi atribuído o valor \texttt{True}, que correspondem aos voos escolhidos, e calcula-se a soma dos custos desses voos. Finalmente, imprimem-se o valor total e os voos escolhidos para o \texttt{stdout}, no formato requerido.

    \section{Avaliação experimental e análise das codificações experimentadas}
        As seguintes tabelas apresentam os tempos, em segundos, que cada uma das codificações leva a executar os testes públicos. A indicação \texttt{TLE} (Time Limit Exceeded) significa que o programa não conseguiu chegar à solução dentro do limite de tempo definido (10 minutos).

        \begin{table}[h]
            \centering
            \begin{tabular}{|c|*{9}{c|}} % Creates the first half with 10 columns (9 data columns)
            \hline
                & T01 & T02 & T03 & T04 & T05 & T06 & T07 & T08 & T09 \\ \hline
            \ref{1} & 0.09 & 0.06 & 0.05 & 0.03 & 0.05 & 0.09 & 0.11 & 0.14 & 0.21 \\ \hline
            \ref{2} & 0.10 & 0.07 & 0.07 & 0.12 & 0.09 & 0.27 & 0.48 & 1.04 & 2.49 \\ \hline
            \end{tabular}
            \caption{Tempos de execução dos testes públicos 1 a 9}
            \label{execution_times_part1}
        \end{table}
        
        \begin{table}[h]
            \centering
            \begin{tabular}{|c|*{9}{c|}} % Creates the second half with 10 columns (9 data columns)
            \hline
                & T10 & T11 & T12 & T13 & T14 & T15 & T16 & T17 & T18 \\ \hline
            \ref{1} & 0.41 & 0.40 & 3.95 & 0.56 & 1.47 & 4.27 & 2.61 & 0.69 & 0.79 \\ \hline
            \ref{2} & 28.14 & 14.96 & 193.59 & 101.00 & 216.54 & 598.75 & TLE & 240.99 & 575.30 \\ \hline
            \end{tabular}
            \caption{Tempos de execução dos testes públicos 10 a 18}
            \label{execution_times_part2}
        \end{table}

        Analisando estes dados, verifica-se que a codificação \ref{1} levou menos tempo do que a codificação \ref{2} a executar todos os testes, sendo bastante mais eficiente. Tal facto revela que a codificação \ref{1} é melhor a limitar o espaço de procura, chegando mais rápido a uma solução.

\end{document}